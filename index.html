<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"
        integrity="sha512-uaz5GpnQoE6t5echKlX8P52czvsIGgLPcvlzfvRubLZ1Hp8JemUDnbUiAahbVtPb+jUVrNETuXvAhDDF/N3M4w=="
        crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    
    <style>
        body {
            padding: 0;
            margin: 0;
            overflow: hidden;
        }
    </style>
    <script defer src="https://unpkg.com/p5.collide2d"></script>
</head>

<body>
    <h1></h1>
    <script>
        
        let windowWidth = window.innerWidth
        let windowHeight = window.innerHeight

        let rectWidth = 25
        let constructionX = 0 + rectWidth / 2
        let constructionY = 0 + rectWidth / 2

        let constructionType = 0
        let iteration = 0
        
        


        let newConstructorX = 0 + rectWidth / 2
        let newConstructorY = 0 + rectWidth / 2

        let forwardType = "downOrient"

        let squareLog = []
        let borderLog = []
        let wallLog = []
        let lootLog = []
        let cameraSpeed = 10

        //formula to determine # of squares for a limit 1 square = 25 px squareLimit * 25 = realLimit
        let upperLimit = 0
        let lowerLimit = 50 * rectWidth
        let leftLimit = 0
        let rightLimit = 100 * rectWidth

        let lootWidth = 0.75

        let backupConstructorX = 0 + rectWidth/2
        let backupConstructorY = 0 + rectWidth/2

        let repeatedSquares = 0
        let dangerZone = 0


        let currentCharacterModel

        let wallTile
        let wallTileDown
        let wallTileRight
        let wallTileLeft
        let LootTypeList = []
        let oppList = []
        //format for rooms: roomLength, room Width, we will multiply the dimensions by rectWidth to ensure uniformity in increments, additionally make sure all measurements are odd #s so that it can fit with hallway tiles
        let roomList = [[7 * rectWidth, 11 * rectWidth], [7*rectWidth, 7*rectWidth], [7*rectWidth, 11*rectWidth]]
        let trueRoomList = []
        let mainCharacter

        //function that randomly generates loot based on room data, returns data containing loot info
        function generateLoot(posX, posY, sizeX, sizeY) {
            //generate a random position for the loot
            let generateComplete = false
            this.x
            this.y
            this.dimensionX = (lootWidth * rectWidth)
            this.dimensionY = (lootWidth * rectWidth)
                //we will make adjustments to position X to make sure loot doesn't generate in the walls
                this.x = random(posX, posX + sizeX - (lootWidth * rectWidth))
                this.y = random(posY, posY + sizeY - (lootWidth * rectWidth) )

                
            
                this.LootType = LootTypeList[Math.floor(random(0, LootTypeList.length))]
    
        }

        let npcScaleFactor = 0.75
        let newAlien
        function newEnemyNPC(modelType) {
            if (modelType == alienModelList[0]) {
                this.health = 100
            }
            else if (modelType == alienModelList[1]) {
                this.health = 150
            }
            else if (modelType == alienModelList[2]) {
                this.health = 200
            }
            this.sizeX = rectWidth * npcScaleFactor 
            this.sizeY = rectWidth * npcScaleFactor 
            let chosenSquare = squareLog[Math.floor(random(0, squareLog.length))]
            // position the enemy accordingly
            this.x = chosenSquare[0] - this.sizeX/2
            this.y = chosenSquare[1] - this.sizeY/2
            this.model = modelType
            this.iterationTime = 500
            this.lastChecked = millis()
            this.movedToNextTile = true
            this.generatedPath = runAI([rectWidth/2, rectWidth/2], [this.x + this.sizeX/2, this.y + this.sizeY/2])
        }

        function player() {
            this.sizeX = rectWidth * npcScaleFactor 
            this.sizeY = rectWidth * npcScaleFactor 
            let chosenSquare = [squareLog[0][0], squareLog[0][1]]
            // position the enemy accordingly
            this.x = chosenSquare[0] - this.sizeX/2
            this.y = chosenSquare[1] - this.sizeY/2
            this.ammo1 = 30
            this.ammo2 = 30
            this.ammo3 = 30
            this.currentWeapon = 0
            this.inventory = [0]
            this.generatedPath = runAI([rectWidth/2, rectWidth/2], [this.x + this.sizeX/2, this.y + this.sizeY/2])

        }


        //this function will help to see if there are any squares in the corner, (we don't want squares to clump up)
        function squareChecker(constructX, constructY, table) {
            let touched = 0
            if (constructX < leftLimit || constructX > rightLimit) {
                touched += 1000
            }
            if (constructY < upperLimit || constructY > lowerLimit) {
                touched += 1000
            }
            for (i = 0; i < table.length; i++) {
                //check to see if a tile is already there
                if (table[i][0] == constructX && table[i][1] == constructY) {
                    touched += 1000
                }

                constructCheckerX = constructX - rectWidth
                constructCheckerY = constructY - rectWidth

                if (constructCheckerX == table[i][0] && constructCheckerY == table[i][1]) {
                    touched += 1
                }

                constructCheckerX = constructX + rectWidth
                constructCheckerY = constructY - rectWidth

                if (constructCheckerX == table[i][0] && constructCheckerY == table[i][1]) {
                    touched += 1
                }

                constructCheckerX = constructX - rectWidth
                constructCheckerY = constructY + rectWidth

                if (constructCheckerX == table[i][0] && constructCheckerY == table[i][1]) {
                    touched += 1
                }

                constructCheckerX = constructX - rectWidth
                constructCheckerY = constructY - rectWidth

                if (constructCheckerX == table[i][0] && constructCheckerY == table[i][1]) {
                    touched += 1
                }
            }

            return touched
        }

        function checkRepeated(x, y) {
            for (i=0;i < squareLog.length; i++) {
                if (squareLog[i][0] == x && squareLog[i][1]) {
                    repeatedSquares += 1
                    break
                }
                
            }
        }

        //check if the room overlaps with any of the hallways
        function checkRoomSpace(room, roomIndex, squareLog) {
            for (let i=0; i<squareLog.length; i++) {
                //cheeck to see if room dimensions overlap with ALL square tiles of the hallways (add padding so that the walls of the room are accounted for)
                if (collideRectRect(room[0] - rectWidth, room[1] - rectWidth, roomList[roomIndex][0] + 2*rectWidth, roomList[roomIndex][1] + 2*rectWidth, squareLog[i][0] - rectWidth/2, squareLog[i][1] - rectWidth/2, rectWidth, rectWidth) == true) {
                    return false
                }
            }
            return true
        }

        //check to see if any rooms overlap with each other
        function checkRoomOverlap(room, roomIndex, dummyRoomList, realRoomList) {
            for (let i=0; i<realRoomList.length; i++) {
                //cheeck to see if room dimensions don't overlap with ALL of the rooms (add padding so that the walls of the room are accounted for)
                if (collideRectRect(room[0] - rectWidth, room[1] - rectWidth, dummyRoomList[roomIndex][0] + rectWidth * 2, dummyRoomList[roomIndex][1] + rectWidth * 2, realRoomList[i][0], realRoomList[i][1], realRoomList[i][2], realRoomList[i][3]) == true) {
                    return false
                }
            }
            return true
        }

        //check if a tile (border) overlaps with any rooms
        function checkRoomBorderOverlap(tile, trueRoomList) {
            for (let i=0;i<trueRoomList.length;i++) {
                //adjust from center orientation to corner orientation
                if (collideRectRect(tile[0] - rectWidth/2, tile[1] - rectWidth/2, rectWidth, rectWidth, trueRoomList[i][0], trueRoomList[i][1], roomList[i][0], roomList[i][1]) == true ){
                    //if there is a collision detected among the tile and the room, return true to say that there should not be a border tile in that position
                    return true
                }
            }

            return false

        }

     
        

        //searched array is the array we are looking for
        function ArrayIncludes(array, searchedValue) {
            for (i=0;i<array.length; i++){
                if (array[i][0] == searchedValue[0] && array[i][1] == searchedValue[1]) {
                    return true
                }
            }
            return false
        }


        function ArrayCompare(array1, array2) {
            for (let i=0;i<array1.length;i++) {
                if (array1[i] != array2[i]){
                    return false
                }
            }
            return true
        }

    
        function ArrayIncludesTwoThree(array, searchedValue) {
            for (i=0;i<array.length; i++){
                if (array[i][1] == searchedValue[1] && array[i][2] == searchedValue[2]) {
                    return true
                }
            }
            return false
        }

        //check to see if we are approaching an intersection
        function intersectionChecker(constructionX, constructionY, squareLog) {
            //generate a list of all the possible corner tiles the tile could have
            //CHECK TO SEE IF THE CONSTRUCTION TILE REACHED THE LIMIT
            if (constructionX < leftLimit || constructionX > rightLimit) {
                return false
            }
            if (constructionY < upperLimit || constructionY > lowerLimit) {
                return false
            }
            if (ArrayIncludes(squareLog, [constructionX, constructionY]) == true) {
                
                return false
            }
            possibleCorners = []
            possibleCorners.push([constructionX - 25, constructionY - 25])
            possibleCorners.push([constructionX + 25, constructionY + 25])
            possibleCorners.push([constructionX - 25, constructionY + 25])
            possibleCorners.push([constructionX + 25, constructionY + 25])
            let indicator = false
            let realCorners = []
            for (let i=0;i<possibleCorners.length; i++) {
                //real tile is a real, placed tile and we will use the variable to check to see if the tile is in a corner of the construction tile 

                if (ArrayIncludes(squareLog, possibleCorners[i]) == true) {
                    realCorners.push(possibleCorners[i])
                }

            }

            for (let i=0;i<realCorners.length;i++) {
                //check to see which corner it is
                //use math to determine the position of the corner tile in relation to the construction tile (formula: cornerCoordinate - constructionTileCoordinate)
                let differenceOfX = realCorners[i][0] - constructionX
                let differenceOfY = realCorners[i][1] - constructionY
                
                //if the corner tile is in the upper left corner
                if(differenceOfX == -rectWidth && differenceOfY == -rectWidth) {
                    //checks the tile BELOW the corner and to the RIGHT of the corner
                    if (ArrayIncludes(squareLog, [realCorners[i][0]+rectWidth, realCorners[i][1]]) == true && ArrayIncludes(squareLog, [realCorners[i][0], realCorners[i][1] + rectWidth]) == true) {
                        return false
                    }
                }
                //if the corner tile is in the upper right corner
                if (differenceOfX == rectWidth && differenceOfY == -rectWidth) {
                    //checks the tile BELOW and to the LEFT of the corner
                    if (ArrayIncludes(squareLog, [realCorners[i][0] - rectWidth, realCorners[i][1]]) == true && ArrayIncludes(squareLog, [realCorners[i][0], realCorners[i][1]+rectWidth]) == true) {
                        return false
                    }
                }
                 //if the corner tile is in the lower left corner
                 if (differenceOfX == -rectWidth && differenceOfY == rectWidth) {
                    //checks the tile ABOVE and to the RIGHT  of the corner
                    if (ArrayIncludes(squareLog, [realCorners[i][0] + rectWidth, realCorners[i][1]]) == true && ArrayIncludes(squareLog, [realCorners[i][0], realCorners[i][1]-rectWidth]) == true) {
                        return false
                    }
                }
                //if the corner tile is in the lower right corner
                if (differenceOfX == rectWidth && differenceOfY == rectWidth) {
                    //checks the tile ABOVE and to the LEFT  of the corner
                    if (ArrayIncludes(squareLog, [realCorners[i][0] - rectWidth, realCorners[i][1]]) == true && ArrayIncludes(squareLog, [realCorners[i][0], realCorners[i][1]-rectWidth]) == true) {
                        return false
                    }
                }
                
            }
        }


        

        // first is target node, second is current node
        function calculateHCostToTarget(targetPos, currentPos) {
            return Math.abs(currentPos[0] - targetPos[0]) + Math.abs(currentPos[1] - targetPos[1])
        }

        let npcCount
        let floorTile
        let alienModelList = []
        let characterModelList = []
        let characterModelListRight = []
        function preload() {
            floorTile = loadImage("floorTile.png")
            wallTile = loadImage("wallTile.png")
            wallTileDown = loadImage("wallTileDown.png")
            wallTileLeft = loadImage("wallTileLeft.png")
            wallTileRight = loadImage("wallTileRight.png")
            wallTileRightCorner = loadImage("wallTileRightCorner.png")
            wallTileLeftCorner = loadImage("wallTileLeftCorner.png")

            //loot
            LootTypeList.push(loadImage("Medkit.png"))
            LootTypeList.push(loadImage("AmmoArt/Ammo1.png"))
            LootTypeList.push(loadImage("AmmoArt/Ammo2.png"))
            LootTypeList.push(loadImage("AmmoArt/Ammo3.png"))
            
            //aliens
            alienModelList.push(loadImage("AlienArt/ClassicAlien.png"))
            alienModelList.push(loadImage("AlienArt/CreepyAlien.png"))
            alienModelList.push(loadImage("AlienArt/CuddlyAlien.png"))

            //main character
            characterModelList.push(loadImage("CharacterArt/MainCharacter1.png"))
            characterModelList.push(loadImage("CharacterArt/MainCharacter2.png"))
            characterModelList.push(loadImage("CharacterArt/MainCharacter3.png"))

            characterModelListRight.push(loadImage("CharacterArt/MainCharacter1Right.png"))
            characterModelListRight.push(loadImage("CharacterArt/MainCharacter2Right.png"))
            characterModelListRight.push(loadImage("CharacterArt/MainCharacter3Right.png"))

        }
        let finalX
        let finalY
        function setup() {
            npcCount = Math.floor(random(2, 3))
            
            
            createCanvas(windowWidth, windowHeight)
            rectMode(CENTER)
            imageMode(CENTER)
            fill(0, 255, 0)
                rect(constructionX, constructionY, rectWidth, rectWidth)
                squareLog.push([constructionX, constructionY])
                
                let russia = 0
                let numberofSquareProduced = 0
                for (let i = 0; squareLog.length < 500; i++) {
                    //determine where the next square is gonna be
                    constructionType = random(0, 25)
                    //moveForward RELATIVE to where the squares are generating
                    //1000 downOrient
                    if (constructionType <= 10) {
                        //~200 downOrient
                        if (forwardType == "downOrient") {
                            constructionY += rectWidth
                        }
                        if (forwardType == "leftOrient") {
                            constructionX -= rectWidth
                        }
                        if (forwardType == "rightOrient") {
                            constructionX += rectWidth
                        }
                        if (forwardType == "upOrient") {
                            constructionY -= rectWidth
                        }
                    
                        if (intersectionChecker(constructionX, constructionY, squareLog) != false && squareChecker(constructionX, constructionY, squareLog) <= 2) {
                            fill(255, 255, 0)
                            image(floorTile, constructionX, constructionY, rectWidth, rectWidth)

                            //add the tile to the log of all the tiles (for future reference)
                            squareLog.push([constructionX, constructionY])

                            backupConstructorX = constructionX
                            backupConstructorY = constructionY
                            dangerZone = 0
                            numberofSquareProduced +=1
                        } 
                        
                        else {
                            i -= 1
                            constructionX = backupConstructorX
                            constructionY = backupConstructorY
                            dangerZone += 1
                            if (dangerZone >= 4) {

                                //if there is no path forward, choose a random tile to go from
                                let randomTile = squareLog[Math.floor(random(0, squareLog.length))]
                                constructionX = randomTile[0]
                                constructionY = randomTile[1]
                            }
                        }

                        

                    }
                    //move LEFT relative to the generation of squares
                    if (constructionType > 10 && constructionType <= 15) {
                        i -=1
                        if (forwardType == "downOrient") {
                            forwardType = "leftOrient"
                            //the variable forwardType here is assigned the left orient value, BUT is not reassigned in the next iteration
                        }
                        else if (forwardType == "leftOrient") {
                            forwardType = "downOrient"
                        }
                        else if (forwardType == "rightOrient") {
                            forwardType = "upOrient"
                        }
                        else if (forwardType == "upOrient") {
                            forwardType = "rightOrient"
                        }
                    }
                    //move RIGHT relative to the generation of squares
                    if (constructionType > 15 && constructionType <= 20) {
                        i -= 1
                        if (forwardType == "downOrient") {
                            forwardType = "rightOrient"
                        }
                        else if (forwardType == "leftOrient") {
                            forwardType = "upOrient"
                        }
                        else if (forwardType == "rightOrient") {
                            forwardType = "downOrient"
                        }
                        else if (forwardType == "upOrient") {
                            forwardType = "leftOrient"
                        }
                    }

                    russia+=1

                    
                }
                finalX = squareLog[squareLog.length - 1][0]
                finalY = squareLog[squareLog.length - 1][1]
                squareLog.pop()

                //after hallway is set up, we will now generate the rooms
                //PROBLEM: #1 how do we see and make sure rooms don't overlap with each other
                //PROBLEM: #2 how to make sure that the room is rotated CORRECTLY, if we just use default dimensional params, the room will always face the same direction, which may not always be suitable, especially since rooms can be generated up and down or side to side
                for (let i=0;i<roomList.length;i++) {
                    //randomly generate an index so that the room will generate in a random place 
                    let randomIndex = Math.floor(random(Math.floor(squareLog.length/2), squareLog.length))
                    let attempt = 0 
                    let type = 0
                    let isItFlippedYet = false

                    // check to see if a left side room is possible
                    //Formula: x: CENTER position of the square tile - 2 tiles - half a tile (to adjust for the center measure and convert to a left measurement) - room width (to get to the left corner)
                    let roomDimension = [squareLog[randomIndex][0] - 2*rectWidth - roomList[i][0] - rectWidth/2, squareLog[randomIndex][1] - roomList[i][1]/2]
                    if (checkRoomSpace(roomDimension, i, squareLog) == true) {
                        //set up for the conditions in which the room will be set up
                        rectMode(CORNERS)
                        rect(roomDimension[0], roomDimension[1], roomList[i][0], roomList[i][1])
                        attempt +=1 
                        generationType = "left"
                        
                    }
                    // check change room dimensions to see if a right side room is possible if a left is not possible
                    else if (attempt == 0) {
                        roomDimension = [squareLog[randomIndex][0] + 2*rectWidth + rectWidth/2, squareLog[randomIndex][1] - roomList[i][1]/2]
                    }
                    if (checkRoomSpace(roomDimension, i, squareLog) == true && attempt == 0) {
                        //set up for the conditions in which the room will be set up
                        rectMode(CORNERS)
                        rect(roomDimension[0], roomDimension[1], roomList[i][0], roomList[i][1])
                        attempt +=1 
                        generationType = "right"
                    }
                    // check change room dimensions to see if a bottom side room is possible if a right/left is not possible
                    else if (attempt == 0) {
                        //flip the X and Y sizes
                        roomList[i].reverse()
                        isItFlippedYet = true
                        roomDimension = [squareLog[randomIndex][0] - roomList[i][0]/2, squareLog[randomIndex][1] + 2*rectWidth + rectWidth/2]
                        
                        
                        
                    }

                    if (checkRoomSpace(roomDimension, i, squareLog) == true && attempt == 0) {
                        //set up for the conditions in which the room will be set up
                        rectMode(CORNERS)
                        rect(roomDimension[0], roomDimension[1], roomList[i][0], roomList[i][1])
                        attempt +=1 
                        generationType = "down"

                    }

                    // check change room dimensions to see if a up side room is possible if a right/left/down is not possible
                    else if (attempt == 0) {
                        roomDimension = [squareLog[randomIndex][0] - roomList[i][0]/2, squareLog[randomIndex][1] - 2*rectWidth - rectWidth/2 - roomList[i][1]]

                        //flip the X and Y sizes if not already
                        if (isItFlippedYet == false) {
                            roomList[i].reverse()
                            isItFlippedYet = true
                        }
                    }

                    if (checkRoomSpace(roomDimension, i, squareLog) == true && attempt == 0) {
                        //set up for the conditions in which the room will be set up
                        rectMode(CORNERS)
                        rect(roomDimension[0], roomDimension[1], roomList[i][0], roomList[i][1])
                        attempt +=1 
                        generationType = "up"
                    }

                    //check to see if rooms overlap each other


                    if (checkRoomOverlap(roomDimension, i, roomList, trueRoomList) == false) {
                        attempt = 0
                    }

                    if (attempt == 0) {
                        if (isItFlippedYet == true) {
                            //flip back the X and Y if it was flipped before
                            roomList[i].reverse()
                        }
                        i -= 1
                    }
                    else {
                        //add the connecting path to the room depending on where the room is
                        //left side room
                        if (generationType == "left")  {
                            let firstSquareX = squareLog[randomIndex][0] - rectWidth
                            squareLog.push([squareLog[randomIndex][0] - rectWidth, squareLog[randomIndex][1]])
                            squareLog.push([squareLog[randomIndex][0] - 2*rectWidth, squareLog[randomIndex][1]])
                        }
                        else if (generationType == "right") {
                            //double as there are 2 squares apart
                            squareLog.push([squareLog[randomIndex][0] + rectWidth, squareLog[randomIndex][1]])
                            squareLog.push([squareLog[randomIndex][0] + 2*rectWidth, squareLog[randomIndex][1]])
                        }
                        
                        else if (generationType == "down") {
                            squareLog.push([squareLog[randomIndex][0], squareLog[randomIndex][1] + rectWidth])
                            squareLog.push([squareLog[randomIndex][0], squareLog[randomIndex][1] + 2*rectWidth])
                        }

                        else if (generationType == "up") {
                            squareLog.push([squareLog[randomIndex][0], squareLog[randomIndex][1] - rectWidth])
                            squareLog.push([squareLog[randomIndex][0], squareLog[randomIndex][1] - 2*rectWidth])
                        }
                        //add the room into the array for later rendering [x, y, sizeX, sizeY]
                        trueRoomList.push([roomDimension[0], roomDimension[1], roomList[i][0], roomList[i][1]])
                    }                    
                }

                //now we create the borders/wall blocks
                // cycle through every hallway tile and check to see if it needs borders
                for (let i=0; i<squareLog.length; i++) {
                    //check to see to the UP side of the tile is viable
                    let tile = [squareLog[i][0], squareLog[i][1] - rectWidth]
                    //make sure there is no impediment in placing a border block there. If there is, don't place the block
                    if (ArrayIncludes(squareLog, tile) != true && checkRoomBorderOverlap(tile, trueRoomList) != true){
                        tile = [squareLog[i][0], squareLog[i][1] - rectWidth]
                        if (ArrayIncludes(borderLog, tile) != true) {
                            borderLog.push(tile)
                        }
                        wallLog.push([wallTile, tile[0], tile[1]])
                    }
                    //check to see to the DOWN side of the tile is viable
                    tile = [squareLog[i][0], squareLog[i][1] + rectWidth]
                    if (ArrayIncludes(squareLog, tile) != true && checkRoomBorderOverlap(tile, trueRoomList) != true){
                        if (ArrayIncludes(borderLog, tile) != true) {
                            borderLog.push(tile)
                        }
                        wallLog.push([wallTileDown, tile[0], tile[1]])
                    }
                    //check to see to the RIGHT side of the tile is viable
                    tile = [squareLog[i][0] + rectWidth, squareLog[i][1]]
                    if (ArrayIncludes(squareLog, tile) != true && checkRoomBorderOverlap(tile, trueRoomList) != true){
                        if (ArrayIncludes(borderLog, tile) != true) {
                            borderLog.push(tile)
                        }
                        wallLog.push([wallTileRight, tile[0], tile[1]])
                    }
                    //check to see to the LEFT side of the tile is viable
                    tile = [squareLog[i][0] - rectWidth, squareLog[i][1]]
                    if (ArrayIncludes(squareLog, tile) != true && checkRoomBorderOverlap(tile, trueRoomList) != true){
                        if (ArrayIncludes(borderLog, tile) != true) {
                            borderLog.push(tile)
                        }
                        wallLog.push([wallTileLeft, tile[0], tile[1]])
                    }

                } 

                //generate borders for rooms
                for (let i = 0; i<trueRoomList.length; i++) {
                    //determine how many times we will have to do the loop (down and up)
                    let numberOfIterationY = trueRoomList[i][3]/rectWidth
                    //determine how many times we will have to do the loop (right and left)
                    let numberOfIterationX = trueRoomList[i][2]/rectWidth
                    
                    let startingPosition = [trueRoomList[i][0] - (rectWidth/2), trueRoomList[i][1] + (rectWidth/2)]
                    //adds border tiles to the left of the room
                    for (let j=0; j<numberOfIterationY; j++) {
                        //only add to the array if there is no overlapping tile
                        if (ArrayIncludes(squareLog, startingPosition) != true) {
                            borderLog.push(startingPosition)
                            wallLog.push([wallTileLeft, startingPosition[0], startingPosition[1]])
                        }
                        else {
                            wallLog.push([wallTile, startingPosition[0], startingPosition[1] - rectWidth])

                            wallLog.push([wallTileDown, startingPosition[0], startingPosition[1] + rectWidth])
                        }
                    
                        startingPosition = [startingPosition[0], startingPosition[1] + rectWidth]
                    }
                    startingPosition = [trueRoomList[i][0] + trueRoomList[i][2] + (rectWidth/2), trueRoomList[i][1] + (rectWidth/2)] 
                    //adds border tiles to the right of the room
                    for (let j=0; j<numberOfIterationY; j++) {
                        //only add to the array if there is no overlapping tile
                        if (ArrayIncludes(squareLog, startingPosition) != true) {
                            borderLog.push(startingPosition)
                            wallLog.push([wallTileRight, startingPosition[0], startingPosition[1]])
                        }
                        else {
                            wallLog.push([wallTile, startingPosition[0], startingPosition[1] - rectWidth])

                            wallLog.push([wallTileDown, startingPosition[0], startingPosition[1] + rectWidth])
                        }
                        
                        startingPosition = [startingPosition[0], startingPosition[1] + rectWidth]
                    }
                    startingPosition = [trueRoomList[i][0] + (rectWidth/2), trueRoomList[i][1] + trueRoomList[i][3] + (rectWidth/2)] 
                    //adds tiles on the bottom of the room
                    for (let j=0; j<numberOfIterationX; j++) {
                        //only add to the array if there is no overlapping tile
                        if (ArrayIncludes(squareLog, startingPosition) != true) {
                            borderLog.push(startingPosition)
                            wallLog.push([wallTileDown, startingPosition[0], startingPosition[1]])
                        }
                        else {
                            wallLog.push([wallTileRight, startingPosition[0] + rectWidth, startingPosition[1]])

                            wallLog.push([wallTileLeft, startingPosition[0] - rectWidth, startingPosition[1]])
                        }
                        startingPosition = [startingPosition[0] + rectWidth, startingPosition[1]]
                    }
                    startingPosition = [trueRoomList[i][0] + (rectWidth/2), trueRoomList[i][1] - (rectWidth/2)] 
                    //adds tiles on the top of the room
                    for (let j=0; j<numberOfIterationX; j++) {
                        //only add to the array if there is no overlapping tile, we will add a true property at the end so that it will not remove a wall tile from the room for the door
                        if (ArrayIncludes(squareLog, startingPosition) != true) {
                            borderLog.push(startingPosition)
                            wallLog.push([wallTile, startingPosition[0], startingPosition[1], true])
                        }
                        else {
                            wallLog.push([wallTileRight, startingPosition[0] + rectWidth, startingPosition[1]])

                            wallLog.push([wallTileLeft, startingPosition[0] - rectWidth, startingPosition[1]])
                        }
                        
                        startingPosition = [startingPosition[0] + rectWidth, startingPosition[1]]
                    }
                    

                }

                //we will create a new array so that it will hold updated priorities to generate the walls
                let trueWallList = []

                //update the priorities
                for (let i=0;i<wallLog.length;i++) {

                    if (wallLog[i][0] != wallTile) {
                        trueWallList.push(wallLog[i])
                    }
                }
                //update the priorities
                let doorSegment = false
                let amountOfWalls = 0
                for (let i=0;i<wallLog.length;i++) {

                    if (wallLog[i][0] == wallTile) {
                        trueWallList.push(wallLog[i])

                        //check to see if one of the wall tiles have a corner that includes a wall
                        if (ArrayIncludesTwoThree(wallLog, [true, wallLog[i][1] - rectWidth, wallLog[i][2] + rectWidth]) == true && ArrayIncludes(squareLog, [wallLog[i][1] - rectWidth, wallLog[i][2]]) != true) {
                            trueWallList.push([wallTileLeftCorner, wallLog[i][1] - rectWidth, wallLog[i][2]])
                        }

                        if (ArrayIncludesTwoThree(wallLog, [true, wallLog[i][1] + rectWidth, wallLog[i][2] + rectWidth]) == true && ArrayIncludes(squareLog, [wallLog[i][1] + rectWidth, wallLog[i][2]]) != true) {
                            trueWallList.push([wallTileRightCorner, wallLog[i][1] + rectWidth, wallLog[i][2]])
                        }
                        if (wallLog[i].length == 3) {
                            amountOfWalls += 1
                        }
                        
                    }
                }

                wallLog = trueWallList
                let indexOfDoor = Math.ceil(random(0, amountOfWalls))
                amountOfWalls = 1

                //choose one of the wall tiles to add a door on

                for (let i=0;i<wallLog.length;  i++) {
                    if (amountOfWalls == indexOfDoor && wallLog[i][0] == wallTile && wallLog[i].length == 3) {
                        wallLog.splice(i, 1)
                    }

                    if (wallLog[i][0] == wallTile && wallLog[i].length == 3){
                        amountOfWalls += 1
                    }
                    
                }

                //loot generation
                for (let i=0; i<trueRoomList.length; i++) {
                    //determine the amount of loot
                    let lootAmount = Math.floor(random(1, (trueRoomList[i][2] * trueRoomList[i][3])/(lootWidth * rectWidth)**2/15))
                    for (let j=0; j<lootAmount;j++) {
                        let loot = new generateLoot(trueRoomList[i][0],trueRoomList[i][1], trueRoomList[i][2], trueRoomList[i][3])
                        lootLog.push(loot)
                    }
                }
                
                //npc ALGORITHM

                //GENERATE NPCs
                for (let i=0;i < npcCount; i++) {
                    let enemy = new newEnemyNPC(alienModelList[0])
                    oppList.push(enemy)
                }

                //put everything in the middle of the screen
                for (let i=0; i<squareLog.length; i++) {
                    squareLog[i][0] += (window.innerWidth/2 - rectWidth)
                    squareLog[i][1] += (window.innerHeight/2 - rectWidth)
                }
                for (let j=0; j< trueRoomList.length; j++) {
                    trueRoomList[j][0] += (window.innerWidth/2 - rectWidth)
                    trueRoomList[j][1] += (window.innerHeight/2 - rectWidth)
                }
                for (let i=0; i<borderLog.length; i++) {
                    borderLog[i][0] += (window.innerWidth/2 - rectWidth)
                    borderLog[i][1] += (window.innerHeight/2 - rectWidth)
                }
                for (let i=0; i<wallLog.length; i++) {
                    wallLog[i][1] += (window.innerWidth/2 - rectWidth)
                    wallLog[i][2] += (window.innerHeight/2 - rectWidth)
                }
                for (let i=0; i<lootLog.length; i++) {
                    lootLog[i].x += (window.innerWidth/2 - rectWidth)
                    lootLog[i].y += (window.innerHeight/2 - rectWidth)
                }
                for (let enemy of oppList) {
                    //change position of enemy
                    enemy.x += (window.innerWidth/2 - rectWidth)
                    enemy.y += (window.innerHeight/2 - rectWidth)
                    if (enemy.generatedPath) {
                        for (let generationTile of enemy.generatedPath) {
                        //adjust the ai path
                        generationTile["pos"][0] += (window.innerWidth/2 - rectWidth)
                        generationTile["pos"][1] += (window.innerHeight/2 - rectWidth)
                    }
                    }
                    
                }
                positionX += cameraSpeed
                mainCharacter = new player()
                if (mainCharacter.currentWeapon == 0) {
                    currentCharacterModel = characterModelListRight[0]
                }
                if (mainCharacter.currentWeapon == 1) {
                    currentCharacterModel = characterModelListRight[1]
                }
                if (mainCharacter.currentWeapon == 2) {
                    currentCharacterModel = characterModelListRight[2]
                }
            
        }
        function runAI(startingPos, targetPos) {
            let openTiles = []
                let closedTiles = []
                let generatedPath = []
                let startingNode = []
                let goalNode = []
                goalNode["pos"] = targetPos
                startingNode["pos"] = startingPos
                startingNode["g"] = 0
                startingNode["h"] = calculateHCostToTarget(goalNode["pos"], startingNode["pos"])
                openTiles.push(startingNode)
                let finishedPathCompletion = false
                let lastMiliCheck = millis()
                
                while (openTiles.length != 0 && finishedPathCompletion == false) {  
                    let lowestIndex = 0
                    //if the open list is greater than 20K, it's time to stop
                    if (closedTiles.length >= 7000) {
                        break
                    }
                    
                    //look at horizontal and vertical tiles to determine score
                    for (let i=0;i<openTiles.length; i++) {
                        //compare and see until we get the lowest possible f cost
                        if (openTiles[i]["g"]+openTiles[i]["h"] < openTiles[lowestIndex]["g"] + openTiles[lowestIndex]["h"]) {
                            lowestIndex = i
                        }
                    }
                    // if the next node is the goal node, refresh
                    if (ArrayCompare(goalNode["pos"], openTiles[lowestIndex]["pos"]) == true) {
                        generatedPath.push(openTiles[lowestIndex])
                        let incrementer = openTiles[lowestIndex]
                        while (finishedPathCompletion == false) {
                            if (Object.keys(incrementer).length == 4) {
                                generatedPath.push(incrementer["parent"])
                                incrementer = incrementer["parent"]
                                
                            }
                            else {
                                finishedPathCompletion = true
                                //reverse the array so the starting tile is first
                                generatedPath.reverse()
                                return generatedPath.reverse()
                            }
                            

                        }
                        
                    }
                    else {
                        //check the up tile as a neighbor
                        let neighborPosition = [openTiles[lowestIndex]["pos"][0], openTiles[lowestIndex]["pos"][1] - rectWidth] 
                        let overlapDetected = false
                        let isClosed = false
                        for (let i=0; i<closedTiles.length; i++) {
                            if (ArrayCompare(closedTiles[i]["pos"], neighborPosition) == true) {
                                isClosed = true
                            }
                        }
                        //make sure bordering tiles are not walls
                        if (ArrayIncludes(borderLog, neighborPosition) != true && ArrayIncludes(squareLog, neighborPosition) == true && isClosed == false) {
                            //calculate g and h costs
                            neighborPosition = []
                            neighborPosition["pos"] = [openTiles[lowestIndex]["pos"][0], openTiles[lowestIndex]["pos"][1] - rectWidth]  
                            neighborPosition["g"] = openTiles[lowestIndex]["g"] + rectWidth
                            neighborPosition["h"] = calculateHCostToTarget(goalNode["pos"], neighborPosition["pos"])
                            neighborPosition["parent"] = openTiles[lowestIndex]
                            for (let i=0;i<openTiles.length; i++) {
                                //if the tile already exists in the open array
                                if (openTiles[i]["pos"] == neighborPosition["pos"]) {
                                    //calculate the f cost of the tiles, if the one we are working now has less f cost, we will remove the old tile and replace it with the new
                                    if (neighborPosition["g"] + neighborPosition["h"] < openTiles[i]["g"] + openTiles[i]["h"]) {
                                        openTiles.splice(i, 1)
                                    }
                                    else {
                                        overlapDetected = true
                                    }
                                }
                            }
                            //add the node to the open array if no overlap was detected
                            if (overlapDetected == false) {
                                openTiles.push(neighborPosition)
                            }
                            
                        }

                        //check the down tile as a neighbor
                        neighborPosition = [openTiles[lowestIndex]["pos"][0], openTiles[lowestIndex]["pos"][1] + rectWidth] 
                        overlapDetected = false
                        isClosed = false
                        for (let i=0; i<closedTiles.length; i++) {
                            if (ArrayCompare(closedTiles[i]["pos"], neighborPosition) == true) {
                                isClosed = true
                            }
                        }
                        //make sure bordering tiles are not walls
                        if (ArrayIncludes(borderLog, neighborPosition) != true && ArrayIncludes(squareLog, neighborPosition) == true && isClosed == false) {
                            //calculate g and h costs
                            
                            neighborPosition = []
                            neighborPosition["pos"] = [openTiles[lowestIndex]["pos"][0], openTiles[lowestIndex]["pos"][1] + rectWidth]  
                            neighborPosition["g"] = openTiles[lowestIndex]["g"] + rectWidth
                            neighborPosition["h"] = calculateHCostToTarget(goalNode["pos"], neighborPosition["pos"])
                            neighborPosition["parent"] = openTiles[lowestIndex]
                            for (let i=0;i<openTiles.length; i++) {
                                //if the tile already exists in the open array
                                if (openTiles[i]["pos"] == neighborPosition["pos"]) {
                                    //calculate the f cost of the tiles, if the one we are working now has less f cost, we will remove the old tile and replace it with the new
                                    if (neighborPosition["g"] + neighborPosition["h"] < openTiles[i]["g"] + openTiles[i]["h"]) {
                                        openTiles.splice(i, 1)
                                    }
                                    else {
                                        overlapDetected = true
                                    }
                                }
                            }
                            //add the node to the open array if no overlap was detected
                            if (overlapDetected == false) {
                                openTiles.push(neighborPosition)
                            }
                            
                        }

                        //check the right tile as a neighbor
                        neighborPosition = [openTiles[lowestIndex]["pos"][0] + rectWidth, openTiles[lowestIndex]["pos"][1]] 
                        overlapDetected = false
                        isClosed = false
                        for (let i=0; i<closedTiles.length; i++) {
                            if (ArrayCompare(closedTiles[i]["pos"], neighborPosition) == true) {
                                isClosed = true
                            }
                        }
                        //make sure bordering tiles are not walls
                        if (ArrayIncludes(borderLog, neighborPosition) != true && ArrayIncludes(squareLog, neighborPosition) == true && isClosed == false) {
                            //calculate g and h costs
                            neighborPosition = []
                            neighborPosition["pos"] = [openTiles[lowestIndex]["pos"][0] + rectWidth, openTiles[lowestIndex]["pos"][1]]  
                            neighborPosition["g"] = openTiles[lowestIndex]["g"] + rectWidth
                            neighborPosition["h"] = calculateHCostToTarget(goalNode["pos"], neighborPosition["pos"])
                            neighborPosition["parent"] = openTiles[lowestIndex]
                            for (let i=0;i<openTiles.length; i++) {
                                //if the tile already exists in the open array
                                if (openTiles[i]["pos"] == neighborPosition["pos"]) {
                                    //calculate the f cost of the tiles, if the one we are working now has less f cost, we will remove the old tile and replace it with the new
                                    if (neighborPosition["g"] + neighborPosition["h"] < openTiles[i]["g"] + openTiles[i]["h"]) {
                                        openTiles.splice(i, 1)
                                    }
                                    else {
                                        overlapDetected = true
                                    }
                                    
                                }
                            }
                            //add the node to the open array if no overlap was detected
                            if (overlapDetected == false) {
                                openTiles.push(neighborPosition)
                            }
                            
                        }

                        //check the left tile as a neighbor
                        neighborPosition = [openTiles[lowestIndex]["pos"][0] - rectWidth, openTiles[lowestIndex]["pos"][1]] 
                        overlapDetected = false
                        isClosed = false
                        for (let i=0; i<closedTiles.length; i++) {
                            if (ArrayCompare(closedTiles[i]["pos"], neighborPosition) == true) {
                                isClosed = true
                            }
                        }
                        //make sure bordering tiles are not walls
                        if (ArrayIncludes(borderLog, neighborPosition) != true && ArrayIncludes(squareLog, neighborPosition) == true && isClosed == false) {
                            //calculate g and h costs
                            neighborPosition = []
                            neighborPosition["pos"] = [openTiles[lowestIndex]["pos"][0] - rectWidth, openTiles[lowestIndex]["pos"][1]]  
                            neighborPosition["g"] = openTiles[lowestIndex]["g"] + rectWidth
                            neighborPosition["h"] = calculateHCostToTarget(goalNode["pos"], neighborPosition["pos"])
                            neighborPosition["parent"] = openTiles[lowestIndex]
                            for (let i=0;i<openTiles.length; i++) {
                                //if the tile already exists in the open array
                                if (openTiles[i]["pos"] == neighborPosition["pos"]) {
                                    //calculate the f cost of the tiles, if the one we are working now has less f cost, we will remove the old tile and replace it with the new
                                    if (neighborPosition["g"] + neighborPosition["h"] < openTiles[i]["g"] + openTiles[i]["h"]) {
                                        openTiles.splice(i, 1)
                                    }
                                    else {
                                        overlapDetected = true
                                    }
                                    
                                }
                            }
                            //add the node to the open array if no overlap was detected
                            if (overlapDetected == false) {
                                openTiles.push(neighborPosition)
                            }
                            
                        }

                        
                      
                        //move the parent tile to "closed category"
                        closedTiles.push(openTiles[lowestIndex])
                        openTiles.splice(lowestIndex, 1)
                    }
                    
                }
        }
        let iterate = 0
        // the ranges: forward(0-10), turnLeft(10-15), turnRight(15-20), turnUp(20-25)
        //NO FILL RAWLY IN DRAW
        let positionX = -3 * rectWidth
        let positionY = -3 * rectWidth

        function checkApproxNPCPos(npcPos) {
            for (let square of squareLog) {
                if (collideRectRect(npcPos[0], npcPos[1], rectWidth * npcScaleFactor, rectWidth * npcScaleFactor, square[0], square[1], rectWidth, rectWidth) == true) {
                    return [square[0], square[1]]
                }
            }

        }

        function createBullet(playerPos, mousePos) {
            this.target = mousePos
            this.x = playerPos[0]
            this.y = playerPos[1] - npcScaleFactor * rectWidth/5
            let xDisplacement = mousePos[0] - playerPos[0]
            let yDisplacement = mousePos[1] - playerPos[1]
            let distance = dist(playerPos[0], playerPos[1], mousePos[0], mousePos[1])
            this.speedX = xDisplacement/distance * 20
            this.speedY = yDisplacement/distance * 20
        }

        let interpolFactor = 0.1
        let playerBulletList = []
        function mouseClicked() {
            if (mainCharacter.currentWeapon == 0 && mainCharacter.ammo1 > 0){
                mainCharacter.ammo1 -= 1
                let createdBullet = new createBullet([mainCharacter.x + mainCharacter.sizeX/2, mainCharacter.y + mainCharacter.sizeY/2], [mouseX, mouseY])
                createdBullet = playerBulletList.push(createdBullet)
            }
        }

        function checkBulletWallCollision(bulletPos) {
            for (let wall of borderLog) {
                let collided = collideRectRect(wall[0] - rectWidth/2, wall[1] - rectWidth/2, rectWidth, rectWidth, bulletPos[0], bulletPos[1], 10, 5)
                if (collided == true) {
                    return true
                }
            }
            return false
        }

        function keyPressed() {
            
        }
            
        function draw() {
            
            

            clear()
            rectMode(CORNER)
            background(70, 70, 70)
            
            document.getElementsByTagName("h1")[0].innerHTML = "X "+ mouseX + "Y "+ mouseY


            fill(140, 140, 140)
            rect(positionX, positionY, rightLimit/2, lowerLimit)

            let leftLock = false
            let rightLock = false
            let downLock = false
            let upLock = false
            
            

            //check to see if player collided with any wall
            for (let wall of wallLog) {
                if (wall[0] == wallTile) {
                    if (collideRectRect(mainCharacter.x, mainCharacter.y, mainCharacter.sizeX/1.5, mainCharacter.sizeY, wall[1] - rectWidth/2 + rectWidth/10, wall[2] + rectWidth/2 - rectWidth/4, rectWidth - rectWidth/10, rectWidth/5) == true) {
                        upLock = true
                    }
                }
                else if (wall[0] == wallTileLeft) {
                    if (collideRectRect(mainCharacter.x, mainCharacter.y, mainCharacter.sizeX/1.5, mainCharacter.sizeY, wall[1] + rectWidth/4 , wall[2] - rectWidth/2 + rectWidth/10, rectWidth/5, rectWidth - rectWidth/10) == true) {
                        leftLock = true
                    }
                }
                else if (wall[0] == wallTileRight) {
                    if (collideRectRect(mainCharacter.x, mainCharacter.y, mainCharacter.sizeX/1.5, mainCharacter.sizeY, wall[1] - rectWidth/2 , wall[2] - rectWidth/2 + rectWidth/10, rectWidth/5, rectWidth - rectWidth/10) == true) {
                        rightLock = true
                    }
                }
                else if (wall[0] == wallTileDown) {
                    if (collideRectRect(mainCharacter.x, mainCharacter.y, mainCharacter.sizeX/1.5, mainCharacter.sizeY, wall[1] - rectWidth/2 + rectWidth/10, wall[2] - rectWidth/2, rectWidth - rectWidth/10, rectWidth/5) == true) {
                        downLock = true
                    }
                }
                
                else if (collideRectRect(mainCharacter.x, mainCharacter.y, mainCharacter.sizeX/1.5, mainCharacter.sizeY, wall[1] - rectWidth/2, wall[2] - rectWidth/2, rectWidth, rectWidth) == true) {
                    if (wall[0] == wallTileLeft) {
                        leftLock = true
                    } 
                    if (wall[0] == wallTileRight) {
                        rightLock = true
                    } 
                    if (wall[0] == wallTileDown) {
                        downLock = true
                    } 
                    rect(wall[1] - rectWidth/2, wall[2] - rectWidth/2, rectWidth, rectWidth)
                }
            }
            rectMode(CENTER)

            //when player moves left, move the squares right
            if (keyIsDown(65) == true && leftLock == false) {
                for (let i=0; i<squareLog.length; i++) {
                    squareLog[i][0] += cameraSpeed
                }
                for (let j=0; j< trueRoomList.length; j++) {
                    trueRoomList[j][0] += cameraSpeed
                }
                for (let i=0; i<borderLog.length; i++) {
                    borderLog[i][0] += cameraSpeed
                }
                for (let i=0; i<wallLog.length; i++) {
                    wallLog[i][1] += cameraSpeed
                }
                for (let i=0; i<lootLog.length; i++) {
                    lootLog[i].x += cameraSpeed
                }
                for (let enemy of oppList) {
                    //change position of enemy
                    enemy.x += cameraSpeed
                    if (enemy.generatedPath) {
                        for (let generationTile of enemy.generatedPath) {
                        //adjust the ai path
                        generationTile["pos"][0] += cameraSpeed
                    }
                    }
                    
                }
                for (let bullet of playerBulletList) {
                    bullet.x += cameraSpeed
                }
                //change orientation of player if they move in the opposite direction
                if (mainCharacter.currentWeapon == 0) {
                    currentCharacterModel = characterModelList[0]
                }
                if (mainCharacter.currentWeapon == 1) {
                    currentCharacterModel = characterModelList[1]
                }
                if (mainCharacter.currentWeapon == 2) {
                    currentCharacterModel = characterModelList[2]
                }
                
                positionX += cameraSpeed
            }
            //when player moves right, move the squares left
            if (keyIsDown(68) == true && rightLock == false) {
                for (let i=0; i<squareLog.length; i++) {
                    squareLog[i][0] -= cameraSpeed
                }
                for (let j=0; j< trueRoomList.length; j++) {
                    trueRoomList[j][0] -= cameraSpeed
                }
                for (let i=0; i<borderLog.length; i++) {
                    borderLog[i][0] -= cameraSpeed
                }
                for (let i=0; i<wallLog.length; i++) {
                    wallLog[i][1] -= cameraSpeed
                }
                for (let i=0; i<lootLog.length; i++) {
                    lootLog[i].x -= cameraSpeed
                }
                for (let enemy of oppList) {
                    //change position of enemy
                    enemy.x -= cameraSpeed
                    if (enemy.generatedPath) {
                        for (let generationTile of enemy.generatedPath) {
                        //adjust the ai path
                        generationTile["pos"][0] -= cameraSpeed
                    }
                    }
                }
                
                //change orientation of player if they move in the opposite direction
                if (mainCharacter.currentWeapon == 0) {
                    currentCharacterModel = characterModelListRight[0]
                }
                if (mainCharacter.currentWeapon == 1) {
                    currentCharacterModel = characterModelListRight[1]
                }
                if (mainCharacter.currentWeapon == 2) {
                    currentCharacterModel = characterModelListRight[2]
                }
                for (let bullet of playerBulletList) {
                    bullet.x -= cameraSpeed
                }
                positionX -= cameraSpeed
            }
            //when player moves up, move the squares down
            if (keyIsDown(87) == true && upLock == false) {
                for (let i=0; i<squareLog.length; i++) {
                    squareLog[i][1] += cameraSpeed
                }
                for (let j=0; j< trueRoomList.length; j++) {
                    trueRoomList[j][1] += cameraSpeed
                }
                for (let i=0; i<borderLog.length; i++) {
                    borderLog[i][1] += cameraSpeed
                }
                for (let i=0; i<wallLog.length; i++) {
                    wallLog[i][2] += cameraSpeed
                }
                for (let i=0; i<lootLog.length; i++) {
                    lootLog[i].y += cameraSpeed
                }
                for (let enemy of oppList) {
                    //change position of enemy
                    enemy.y += cameraSpeed
                    if (enemy.generatedPath) {
                        for (let generationTile of enemy.generatedPath) {
                        //adjust the ai path
                        generationTile["pos"][1] += cameraSpeed
                    }
                    }
                    
                }
                for (let bullet of playerBulletList) {
                    bullet.y += cameraSpeed
                }
                positionY += cameraSpeed
            }
            //when the players moves down, moves the squares up
            if (keyIsDown(83) == true && downLock == false) {
                for (let i=0; i<squareLog.length; i++) {
                    squareLog[i][1] -= cameraSpeed
                }
                for (let j=0; j< trueRoomList.length; j++) {
                    trueRoomList[j][1] -= cameraSpeed
                }
                for (let i=0; i<borderLog.length; i++) {
                    borderLog[i][1] -= cameraSpeed
                }
                for (let i=0; i<wallLog.length; i++) {
                    wallLog[i][2] -= cameraSpeed
                }
                for (let i=0; i<lootLog.length; i++) {
                    lootLog[i].y -= cameraSpeed
                }
                for (let enemy of oppList) {
                    //change position of enemy
                    enemy.y -= cameraSpeed
                    if (enemy.generatedPath) {
                        for (let generationTile of enemy.generatedPath) {
                        //adjust the ai path
                        generationTile["pos"][1] -= cameraSpeed
                    }
                    }
                    
                }
                for (let bullet of playerBulletList) {
                    bullet.y -= cameraSpeed
                }
                positionY -= cameraSpeed
            }
            
            

            fill(0, 255, 0)
            imageMode(CENTER)
            for (let i=0; i<squareLog.length; i++) {
                image(floorTile, squareLog[i][0], squareLog[i][1], rectWidth, rectWidth)
            }

            fill(140, 140, 140)
            noStroke()
            for (let i=0; i<borderLog.length; i++) {
                
                rect(borderLog[i][0], borderLog[i][1], rectWidth, rectWidth)
            }
            for (let i= 0; i <wallLog.length; i++) {
                image(wallLog[i][0], wallLog[i][1], wallLog[i][2], rectWidth, rectWidth)
            }

            


            rectMode(CORNER)
            fill(82,82,82)
            for (let j=0; j< trueRoomList.length; j++) {
                rect(trueRoomList[j][0], trueRoomList[j][1], trueRoomList[j][2], trueRoomList[j][3])
            }

            fill(255, 0, 0)

            imageMode(CORNER)
            
            for (let i= 0; i <lootLog.length; i++) {
                image(lootLog[i].LootType, lootLog[i].x, lootLog[i].y, lootLog[i].dimensionX, lootLog[i].dimensionY)
            }
            if (iterate == 0) {
                iterate += 1
            }
            else if (iterate == 1) {
                iterate += 1
                
            }
            lastMiliCheck = millis()
            fill(255, 0, 0)
            rectMode(CENTER) 

            imageMode(CORNER) 
            for (let i=0; i<oppList.length; i++) {
                //update generated path every 5 secs
                if (millis() - oppList[i].lastChecked > oppList[i].iterationTime) {
                    oppList[i].lastChecked = millis()
                    let orgPosition = checkApproxNPCPos([mainCharacter.x + mainCharacter.sizeX/2, mainCharacter.y + mainCharacter.sizeY/2])
                    // check to see if it's worth pursing the player
                    // insert code here
                    oppList[i].generatedPath = runAI(orgPosition, checkApproxNPCPos([oppList[i].x + oppList[i].sizeX/2, oppList[i].y + oppList[i].sizeY/2]))
                
                }
                let targetVector
                let enemyVector
                
                //iterate through the path to see which tile is the closest to the NPC, if a path exists
                if (oppList[i].generatedPath) {
                    for (let j = 0;j<oppList[i].generatedPath.length - 1; j++) {
                        // if the next tile, exists, let the algorithm continue
                        if (oppList[i].generatedPath.indexOf(j + 1)) {

                            if (oppList[i].movedToNextTile == true) {
                                oppList[i].enemyVector = createVector(oppList[i].x + oppList[i].sizeX/2, oppList[i].y + oppList[i].sizeY/2)
                                oppList[i].targetVector = createVector(oppList[i].generatedPath[j + 1]["pos"][0],oppList[i].generatedPath[j + 1]["pos"][1])

                            }
                            oppList[i].movedToNextTile = false
                            let speedX = (oppList[i].targetVector.x - oppList[i].enemyVector.x)/dist(oppList[i].targetVector.x, oppList[i].targetVector.y, oppList[i].enemyVector.x, oppList[i].enemyVector.y) * 5
                            let speedY = (oppList[i].targetVector.y - oppList[i].enemyVector.y)/dist(oppList[i].targetVector.x, oppList[i].targetVector.y, oppList[i].enemyVector.x, oppList[i].enemyVector.y) * 5  
                            oppList[i].x += speedX
                            oppList[i].y += speedY
                            if (dist(oppList[i].x + oppList[i].sizeX/2, oppList[i].y + oppList[i].sizeY/2, oppList[i].targetVector.x, oppList[i].targetVector.y) <= 1) {
                                oppList[i].generatedPath.splice(0, 1)
                                console.log("THIS RAN")
                                interpolFactor = 0.1
                                oppList[i].movedToNextTile = true
                            }
                            break
                        }
                       
                    }
                }
                //if a path don't exist, don't change anything
                else {
                    oppList[i].enemyVector = createVector(oppList[i].x + oppList[i].sizeX/2, oppList[i].y + oppList[i].sizeY/2)
                    oppList[i].targetVector = createVector(oppList[i].x + oppList[i].sizeX/2, oppList[i].y + oppList[i].sizeX/2)
                }
                

                
                
                image(oppList[i].model, oppList[i].x, oppList[i].y, oppList[i].sizeX, oppList[i].sizeY)
            }

            for (let bullet of playerBulletList) {
                bullet.x += bullet.speedX
                bullet.y += bullet.speedY
                rectMode(CENTER)
                fill(255, 255, 0)
                //check to see if bullet collided with a wall
                if (checkBulletWallCollision([bullet.x, bullet.y]) == true) {
                    //if it did collide take the bullet out of the system
                    playerBulletList.splice(playerBulletList.indexOf(bullet), 1)
                }
                else {
                    rect(bullet.x, bullet.y, 10, 5)
                }
                
            }
            image(currentCharacterModel, mainCharacter.x, mainCharacter.y, mainCharacter.sizeX, mainCharacter.sizeY)
        
        }
    </script>
</body>

</html>